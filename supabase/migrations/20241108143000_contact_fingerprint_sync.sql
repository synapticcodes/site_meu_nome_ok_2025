set check_function_bodies = off;
create extension if not exists pgcrypto with schema extensions;
create extension if not exists pg_net with schema extensions;
create or replace function public.normalize_contact_email(value text)
returns text
language sql
immutable
as $$
  select case when value is null then null else nullif(lower(trim(value)), '') end;
$$;
create or replace function public.normalize_contact_phone(value text)
returns text
language plpgsql
immutable
as $$
declare
  digits text;
begin
  if value is null then
    return null;
  end if;

  digits := regexp_replace(value, '[^0-9]', '', 'g');
  if length(digits) = 0 then
    return null;
  end if;

  return '+' || digits;
end;
$$;
create or replace function public.compute_contact_fingerprint(p_email text, p_phone text)
returns text
language sql
immutable
as $$
  select case
    when coalesce(p_email, '') = '' and coalesce(p_phone, '') = '' then null
    else encode(extensions.digest(convert_to(coalesce(p_email, '') || '|' || coalesce(p_phone, ''), 'UTF8'), 'sha256'::text), 'hex')
  end;
$$;
alter table if exists public.leads_captura
  add column if not exists contact_fingerprint text;
alter table if exists public.deals
  add column if not exists contact_fingerprint text;
create index if not exists idx_leads_captura_contact_fingerprint on public.leads_captura (contact_fingerprint);
create index if not exists idx_deals_contact_fingerprint on public.deals (contact_fingerprint);
create or replace function public.set_contact_fingerprint_on_leads()
returns trigger
language plpgsql
security definer
set search_path = public
as $$
begin
  new.contact_fingerprint := public.compute_contact_fingerprint(
    public.normalize_contact_email(new.lead_email),
    public.normalize_contact_phone(new.lead_phone)
  );
  return new;
end;
$$;
create or replace function public.set_contact_fingerprint_on_deals()
returns trigger
language plpgsql
security definer
set search_path = public
as $$
begin
  new.contact_fingerprint := public.compute_contact_fingerprint(
    public.normalize_contact_email(new.deal_email),
    public.normalize_contact_phone(new.deal_phone)
  );
  return new;
end;
$$;
drop trigger if exists trg_leads_contact_fingerprint on public.leads_captura;
create trigger trg_leads_contact_fingerprint
  before insert or update on public.leads_captura
  for each row
  execute function public.set_contact_fingerprint_on_leads();
drop trigger if exists trg_deals_contact_fingerprint on public.deals;
create trigger trg_deals_contact_fingerprint
  before insert or update on public.deals
  for each row
  execute function public.set_contact_fingerprint_on_deals();
update public.leads_captura lc
set contact_fingerprint = public.compute_contact_fingerprint(
  public.normalize_contact_email(lc.lead_email),
  public.normalize_contact_phone(lc.lead_phone)
)
where contact_fingerprint is null;
update public.deals d
set contact_fingerprint = public.compute_contact_fingerprint(
  public.normalize_contact_email(d.deal_email),
  public.normalize_contact_phone(d.deal_phone)
)
where contact_fingerprint is null;
create table if not exists public.crm_tracker_settings (
  id integer primary key default 1 check (id = 1),
  lead_status_url text,
  secret text,
  retry_limit integer not null default 5,
  is_active boolean not null default true,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);
do $$
begin
  if not exists (select 1 from public.crm_tracker_settings) then
    insert into public.crm_tracker_settings (id, is_active) values (1, true);
  end if;
end;
$$;
create table if not exists public.crm_tracker_sync_log (
  id bigint generated by default as identity primary key,
  deal_id uuid not null references public.deals(id) on delete cascade,
  contact_fingerprint text not null,
  deal_status text not null,
  attempt integer not null default 1,
  success boolean not null default false,
  response_status integer,
  response_headers jsonb,
  response_body jsonb,
  error_message text,
  payload jsonb not null,
  next_retry_at timestamptz,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);
create index if not exists idx_crm_tracker_sync_log_deal on public.crm_tracker_sync_log (deal_id);
create index if not exists idx_crm_tracker_sync_log_fingerprint on public.crm_tracker_sync_log (contact_fingerprint);
create index if not exists idx_crm_tracker_sync_log_retry on public.crm_tracker_sync_log (success, next_retry_at);
create or replace function public.set_updated_at()
returns trigger
language plpgsql
as $$
begin
  new.updated_at = now();
  return new;
end;
$$;
drop trigger if exists trg_crm_tracker_settings_updated_at on public.crm_tracker_settings;
create trigger trg_crm_tracker_settings_updated_at
  before update on public.crm_tracker_settings
  for each row
  execute function public.set_updated_at();
drop trigger if exists trg_crm_tracker_sync_log_updated_at on public.crm_tracker_sync_log;
create trigger trg_crm_tracker_sync_log_updated_at
  before update on public.crm_tracker_sync_log
  for each row
  execute function public.set_updated_at();
create or replace function public.notify_crm_tracker_on_deal_status()
returns trigger
language plpgsql
security definer
set search_path = public
as $$
declare
  v_settings public.crm_tracker_settings%rowtype;
  v_response jsonb;
  v_status integer;
  v_success boolean := false;
  v_error text;
  v_payload jsonb;
begin
  if tg_op <> 'UPDATE' then
    return new;
  end if;

  if coalesce(old.deal_status, '') = coalesce(new.deal_status, '') then
    return new;
  end if;

  if new.deal_status not in ('contrato_enviado', 'contrato_assinado') then
    return new;
  end if;

  if new.contact_fingerprint is null then
    v_error := 'contact fingerprint not available';
  else
    select *
      into v_settings
    from public.crm_tracker_settings
    where is_active
    order by updated_at desc
    limit 1;

    if v_settings.lead_status_url is null or v_settings.secret is null then
      v_error := 'crm_tracker_settings misconfigured';
    else
      v_payload := jsonb_build_object(
        'contact_fingerprint', new.contact_fingerprint,
        'deal_id', new.id,
        'status', new.deal_status,
        'updated_at', coalesce(new.updated_at, now()),
        'source', 'crm-heart',
        'metadata', jsonb_build_object(
          'deal_full_name', new.deal_full_name,
          'deal_email', new.deal_email,
          'deal_phone', new.deal_phone,
          'vendedor_responsavel', new.vendedor_responsavel
        )
      );

      begin
        v_response := net.http_post(
          url => v_settings.lead_status_url,
          headers => jsonb_build_object(
            'Content-Type', 'application/json',
            'X-CRM-TRACKER-SECRET', v_settings.secret
          ),
          body => v_payload::text
        );
        v_status := (v_response ->> 'status')::int;
        v_success := v_status between 200 and 299;
        if not v_success then
          v_error := coalesce(v_response ->> 'body', 'unexpected response body');
        end if;
      exception when others then
        v_error := sqlerrm;
      end;
    end if;
  end if;

  insert into public.crm_tracker_sync_log (
    deal_id,
    contact_fingerprint,
    deal_status,
    payload,
    response_status,
    response_headers,
    response_body,
    success,
    error_message,
    next_retry_at
  )
  values (
    new.id,
    coalesce(new.contact_fingerprint, old.contact_fingerprint),
    new.deal_status,
    coalesce(v_payload, jsonb_build_object(
      'contact_fingerprint', new.contact_fingerprint,
      'deal_id', new.id,
      'status', new.deal_status
    )),
    v_status,
    case when v_response is not null and v_response ? 'headers' then v_response -> 'headers' else null end,
    case
      when v_response is not null and v_response ? 'body' then to_jsonb(v_response ->> 'body')
      else v_response
    end,
    v_success,
    v_error,
    case when v_success then null else now() + interval '15 minutes' end
  );

  return new;
end;
$$;
drop trigger if exists trg_notify_crm_tracker on public.deals;
create trigger trg_notify_crm_tracker
  after update on public.deals
  for each row
  execute function public.notify_crm_tracker_on_deal_status();
drop function if exists public.convert_lead_to_deal(uuid);
create or replace function public.convert_lead_to_deal(p_lead_id uuid)
returns uuid
language plpgsql
security definer
set search_path = public
as $$
declare
  v_lead record;
  v_deal_id uuid;
  v_fingerprint text;
begin
  select * into v_lead from public.leads_captura where id = p_lead_id;

  if not found then
    raise exception 'Lead % not found', p_lead_id;
  end if;

  v_fingerprint := coalesce(
    v_lead.contact_fingerprint,
    public.compute_contact_fingerprint(
      public.normalize_contact_email(v_lead.lead_email),
      public.normalize_contact_phone(v_lead.lead_phone)
    )
  );

  insert into public.deals (
    deal_first_name,
    deal_last_name,
    deal_full_name,
    deal_phone,
    deal_email,
    deal_status,
    vendedor_responsavel,
    contact_fingerprint
  )
  values (
    v_lead.lead_first_name,
    v_lead.lead_last_name,
    nullif(trim(concat_ws(' ', v_lead.lead_first_name, v_lead.lead_last_name)), ''),
    v_lead.lead_phone,
    v_lead.lead_email,
    'negocio_novo',
    v_lead.vendedor_responsavel,
    v_fingerprint
  )
  returning id into v_deal_id;

  update public.leads_captura
  set
    lead_status = 'convertido',
    contact_fingerprint = v_fingerprint,
    updated_at = now()
  where id = p_lead_id;

  return v_deal_id;
end;
$$;
revoke all on function public.convert_lead_to_deal(uuid) from public;
grant execute on function public.convert_lead_to_deal(uuid) to authenticated;
grant execute on function public.convert_lead_to_deal(uuid) to service_role;
revoke all on public.crm_tracker_settings from public;
revoke all on public.crm_tracker_sync_log from public;
grant select, update on public.crm_tracker_settings to service_role;
grant insert, update, select on public.crm_tracker_sync_log to service_role;
